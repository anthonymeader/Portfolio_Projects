-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\Antho\Desktop\EELE_468\eq\hdlsrc\bandpass_eq\waitForData.vhd
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: waitForData
-- Source Path: bandpass_eq/fftAnalysisSynthesis/analysis/fftFrameBuffering/fftPulseGen/waitForData
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY waitForData IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_2048_0                      :   IN    std_logic;
        framePulse                        :   IN    std_logic;
        fftFramePulse                     :   OUT   std_logic
        );
END waitForData;


ARCHITECTURE rtl OF waitForData IS

  ATTRIBUTE multstyle : string;

  -- Signals
  SIGNAL count_step                       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_from                       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL initialFrameCount_out1           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count                            : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL need_to_wrap                     : std_logic;
  SIGNAL count_value                      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL count_1                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Bitwise_Operator_out1            : std_logic;
  SIGNAL Logical_Operator1_out1           : std_logic;

BEGIN
  -- Frame pulses don't start
  -- coming through until 
  -- circular buffer has data.  
  -- Counter starts a zero and counts number of frame pulses.
  -- Counter remains enabled while frame count is less than 4.
  -- As soon as the counter reaches 4, it is disabled, which then
  -- enables the frame pulses to pass through.
  -- framePulse
  -- will pass through 
  -- when enabled
  -- Number of Frames
  -- to wait before starting
  -- Start performing FFTs after enough data has filled the circular buffer.
  -- This is due to the fact that we don't want the read pointer (addrB) 
  -- to catch up with the  write pointer (addrA) because if it does,
  -- the dpRAM will throw an assertion error.

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 4
  count_step <= to_unsigned(16#01#, 5);

  count_from <= to_unsigned(16#00#, 5);

  count <= initialFrameCount_out1 + count_step;

  
  need_to_wrap <= '1' WHEN initialFrameCount_out1 = to_unsigned(16#04#, 5) ELSE
      '0';

  
  count_value <= count WHEN need_to_wrap = '0' ELSE
      count_from;

  Logical_Operator_out1 <= Compare_To_Constant_out1 AND framePulse;

  
  count_1 <= initialFrameCount_out1 WHEN Logical_Operator_out1 = '0' ELSE
      count_value;

  initialFrameCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      initialFrameCount_out1 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_0 = '1' THEN
        initialFrameCount_out1 <= count_1;
      END IF;
    END IF;
  END PROCESS initialFrameCount_process;


  
  Compare_To_Constant_out1 <= '1' WHEN initialFrameCount_out1 < to_unsigned(16#04#, 5) ELSE
      '0';

  Bitwise_Operator_out1 <=  NOT Compare_To_Constant_out1;

  Logical_Operator1_out1 <= framePulse AND Bitwise_Operator_out1;

  fftFramePulse <= Logical_Operator1_out1;

END rtl;

